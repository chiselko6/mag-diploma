\subsection{Выполнение операции \join}
\label{sec:technology:join}

Более того, среди возможных проблем производительности – операции \join. Такие операции встречаются довольно часто, в бизнес-\-пра\-ви\-лах их не избежать. Оптимизатор всякий раз выбирает последовательность параметров, по которой ему стоит выполнять \join. Во время операции он использует ключи из тела предиката, эвристически пытаясь отфильтровать данные как можно раньше, чтобы тем самым сократить размер дальнейшей информации для обработки.
Для примера выберем следующий предикат:

\begin{lstlisting}[language=Prolog]
fcst_in_range[sku, store, week] = f <-
  fcst[sku, store, week]=f,
  future_week(week).
\end{lstlisting}

В данном примере возможные (из самых логичных) последовательности объединения – \lstinline{(sku, store, week)}, \lstinline{(week, sku, store)}. Очевидно, что для \lstinline{(sku, store, week)} придется затронуть все страницы для выполнения операции.

Для применения операции из \lstinline{(week, sku, store)} с \lstinline{(sku, store, week)} создается индекс с этой последовательностью ключей. Индексы создаются автоматически, когда это надо.

Наш пример преобразуется в:

\begin{lstlisting}[language=Prolog]
fcst$2_0_1_3[week, sku, store] = f <-
  fcst[sku, store, week] = f.
\end{lstlisting}

После создания индекса, среда выполнит вычисления:

\begin{lstlisting}[language=Prolog]
fcst_in_range[sku, store, week] = f <-
  fcst$2_0_1_3[week, sku, store] = f,
  future_week(week).
\end{lstlisting}

Замечание: приведенные операции выполняются автоматически, то есть все, что может знать разработчик, - можно узнать из логов.

Но с индексами также возможны проблемы:

\begin{enumerate}
  \item При большом количестве операций \join и больших индексах, пользователю приходится ждать завершения материализации индекса.
  \item Индексы все-таки занимают дополнительную память – память увеличивается вдвое, поскольку индекс такой же по размеру, как и предикат, для которого он создается.
  \item Если индекс был создан в \emph{read-only} транзакции, то он не может быть дальше использован после обновления базового для индекса предиката, поскольку данные изменились. В этом случае индекс удаляется при изменении самого предиката. Но, опять же, при постоянных чередующихся запросах на получение результата и изменение предиката, индекс будет создаваться и удаляться каждый раз, что ведет к замедлению работы использования индексов.
\end{enumerate}

С этими проблемами частично справляется пресоздания индексов. Это делается во время дневного скрипта, когда время не играет важную роль. Такие индексы хорошо создавать для тех предикатов, которые не могут быть изменены пользователем, например, предикаты, которые используют прогноз продаж, ведь они используют данные прошлых дней, что является неизменным. Тем самым этот подход стоит лишь дополнительного времени выполнения дневного скрипта и требует больше памяти для хранения, но в целом дает неплохие результаты. Также, абсолютно не рекомендуется создавать такие индексы для больших предикатов, которые обновляется через \ui.
