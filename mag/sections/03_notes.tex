\subsection{Выводы}
\label{sec:optimization:notes}

\begin{itemize}
  \item компилятор переписывает сложные формулы с функциональными предикатами и операторами сравнения в атомарные инструкции;
  \item выбранный порядок ключей при операциях \join часто является причиной длительных запросов (long-running rules). Такие случаи легко выявить при изучении ключей в исходном правиле;
  \item некоторые правила выходят за рамки линейной асимптотики, что плохо сказывается на производительности из-за большого количества исходных данных;
  \item следует избегать правил, которые делают \join по временным объектам, используя неравенства. Вместо этого лучше использовать конструкцию \lstinline{int:range};
  \item стоит хорошо называть промежуточные предикаты, введенные для оптимизации, а также добавлять соответствующие комментарии к ним, чтобы с течением времени эти изменения не были удалены и по-прежнему были понятны;
  \item при использовании \lstinline{force_key_ordering} pragma стоит ставить меньше ключей, чтобы меньше ограничивать оптимизатор;
  \item полезно придерживаться одного шаблона при pragma, например часто используется следующий формат: $"pragma" + $ \lstinline{string} $ +$\linebreak $ "force\_key\_ordering"$;
  \item запись в логах, содержащая \lstinline{long-running "ExUnRule"}, указывает на блок и номер строки с самой long-running rule;
  \item чтобы вывести самые долгие правила, необходимы выполнить \lstinline{grep took lb-server.log |}\lstinline| awk '{print $(NF-1) " " $0;}'|\lstinline{ | sort -r -n|}
  \item настройка окружения \lstinline{LB_SUPPRESS_TASK_PARALLELISM=1} помогает логу быть в едином потоке, в противном случае записи будут находиться в хаотичном порядке;
\end{itemize}
